### 什么是执行上下文?
    执行上下文可以理解为js代码运行时所处的抽象环境，根据代码片段类型不同，分为全局执行上下文，函数执行上下文，eval执行上下文。一个执行上下文分为三部分: this指针 词法环境组件 变量环境组件。 词法环境组件和变量环境组件 都是由 词法环境对象构成， 词法环境对象 由 环境记录器和 可能存在的外部环境引用组成。 根据上下文不同， 环境记录器又有声明式和对象式两类。

    词法环境对象 = 环境记录器 + 外部环境引用  词法环境组件、变量环境组件都由词法环境对象构成。 执行上下文 = this + 词法环境组件 + 变量环境组件

    通俗点来说，在执行上下文里面定义了this指向, 各个标识符的指向。

### 函数执行前，会扫描函数体内的所有代码，按照一定的规则, 创建执行上下文
1. var 声明的变量，不管是在哪里声明的(就算是在if或者for循环while循环里面声明的也一样)，都会被提升到当前函数上下文的变量环境组件中, 并初始化为undefined
2. 在函数外层, let 和 const声明的变量会被定义到词法环境组件中, 不会被初始化。代码块里面声明的let和const, 不会进行声明提升, 如果在代码块外部引用，将会抛出is not defined错误
3. 如果是同名的函数声明和**var**变量声明, 函数声明会覆盖变量声明, 位置靠后的声明会覆盖靠前的声明
4. **代码块**里面的函数声明, 会被当成一个var变量提升到变量环境组件, 只有进入当前代码块的时候才会被声明为函数定义
5. 显示的赋值操作的优先级比声明的优先级高(a = 100这种有赋值操作符的赋值操作)，会更新代码里的标识符指向。 但是也有意外, 函数调用的时候，形参的隐式赋值的优先级居然比函数声明低，同名的形参会被函数声明覆盖。
```
function test(a) {
    console.log(a);
    function a() {}
}
test(1) 打印的是function a() {}
```
6. let和const如果出现在代码块里，在执行流进入块的时候, 会创建一个block上下文, 然后let和const声明在block上下文之中, 并且执行流出块的时候, block上下文会被销毁。

### 作用域和作用域链
由上下文应该知道，上下文里面的词法环境对象已经定义好了代码内标识符的查找规则，可以说词法环境就是对应的作用域了，当前上下文没有找到对应标识符的时候，就会根据词法环境的父级上下文引用去找，直到最底层的全局上下文，这样子就构成了作用域链。

### this
this是上下文中比较关键的一块, this绑定一共有5种情况
* 默认绑定，没有任何调用方的绑定即为隐式绑定。非严格模式下this指向全局对象(浏览器里是window), 严格模式下是undefined
* 隐式绑定
* 显示绑定
* new构造函数绑定
* 箭头函数
重点说一下箭头函数，箭头函数的this继承外部上下文的this，并且箭头函数的this一旦绑定，不能通过call\apply\或者bind二次修改
另外构造函数里面定义的箭头函数， 箭头函数的this继承外部的this，也就是构造函数的this，构造函数的this又指向其实例对象，所以构造函数里的箭头函数的this指向其实例对象。







    


