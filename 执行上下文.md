### 什么是执行上下文?
    执行上下文可以理解为js代码运行时所处的抽象环境，根据代码片段类型不同，分为全局执行上下文，函数执行上下文，eval执行上下文。一个执行上下文分为三部分: this指针 词法环境组件 变量环境组件。 词法环境组件和变量环境组件 都是由 词法环境对象构成， 词法环境对象 由 环境记录器和 可能存在的外部环境引用组成。 根据上下文不同， 环境记录器又有声明式和对象式两类。

    词法环境对象 = 环境记录器 + 外部环境引用  词法环境组件、变量环境组件都由词法环境对象构成。 执行上下文 = this + 词法环境组件 + 变量环境组件

    通俗点来说，在执行上下文里面定义了this指向, 各个标识符的指向。

### 函数执行前，会扫描函数体内的所有代码，按照一定的规则, 创建执行上下文
1. var 声明的变量，不管是在哪里声明的(就算是在if或者for循环while循环里面声明的也一样)，都会被提升到当前函数上下文的变量环境组件中, 并初始化为undefined
2. 在函数外层, let 和 const声明的变量会被定义到词法环境组件中, 不会被初始化。代码块里面声明的let和const, 不会进行声明提升, 如果在代码块外部引用，将会抛出is not defined错误
3. 如果是同名的函数声明和**var**变量声明, 函数声明会覆盖变量声明, 位置靠后的声明会覆盖靠前的声明
4. **代码块**里面的函数声明, 会被当成一个var变量提升到变量环境组件, 只有进入当前代码块的时候才会被声明为函数定义
5. 赋值操作的优先级比声明的优先级高，会更新代码里的标识符指向。 但是也有意外, 函数调用的时候，形参赋值的优先级居然比函数声明低，同名的形参会被函数声明覆盖。
6. let和const如果出现在代码块里，在执行流进入块的时候, 会创建一个block上下文, 然后let和const声明在block上下文之中, 并且执行流出块的时候, block上下文会被销毁。

### 作用域和作用域链
由上下文应该知道，上下文里面的词法环境对象已经定义好了代码内标识符的查找规则，可以说词法环境就是对应的作用域了，当前上下文没有找到对应标识符的时候，就会根据词法环境的父级上下文引用去找，直到最底层的全局上下文，这样子就构成了作用域链。

### 闭包







    


