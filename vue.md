感觉思路不太对, 单纯的去记忆是什么意义不大，永远记住需求驱动技术的进步! 而且对比理解是很好的方法?
如何系统化的去理解掌握一个框架的知识点
# 思想 
数据驱动视图，在数据变更时同步视图的更新
## 核心
### 声明式渲染
* 属性
    v-bind|:
    :class 做合并而不是覆盖
* 方法
    v-on|@
    修饰符接管部分事件操作
    .capture 在捕获阶段响应
    .self 只响应自己触发的事件
    .stop 阻止冒泡
    .prevent 阻止默认事件
    .native 原生事件
    .once 只响应一次
    .passive 明确告诉浏览器不会阻止默认事件，在滚动的时候性能提升明显
    针对键盘事件的优化写法, 为常用的键位设置了别名, 简化
    @keyup.enter=""
    .enter 
    .esc
    .tab
    .space
    .delete
    .up
    .down
    .left
    .right
    并且为组合按键提供了修饰符
    .ctrl .shilft .alt .meta
    v-on:keyup.ctrl.enter = ''
    鼠标用修饰符
    .left
    .right
    .middle
    学东西不要光学眼前, 类比、扩展、总结都是很必要的, 这样子才能以点成线，以线成面，最终构建称为自己的一套知识体系。
* 结构
    v-if | v-for | v-show
### 生命周期

### 组件式构建应用


























































#### vue
1. 构建页面
首先是在根实例上需要用el来确定vue的接管范围, 构建页面或者组件和编写常规意义上的html过程一样。 响应式的值、属性、事件、dom片段由vue对应的指令来实现。然后css也和开发普通html差不多，
直接写就完事， 然后呢， 为了满足组件私有，至少别影响其他组件的吧, 就提供了scope来限定。
2. 数据及页面的逻辑
所有需要响应式的数据，必须在data里进行提前声明, 在生命周期钩子里获取数据，在methods定义方法响应事件和内部逻辑。
3. 针对大型的应用，由vue-router 来提供 路由和组件的一级级对应， 由vuex来提供状态管理。
4. 

单从数据说:
页面或组件本身的数据: data 里面声明就可以用    
从父级拿数据: props 可以简单的写拿了啥 ['name', 'year'], 也可以详细的声明拿的啥，是什么类型，默认值是啥，校验规则确定父级传下来的对不对. 然后推荐大家用后者
想改数据: sorry 子不能直接改，告诉爹， 你想改成啥， 爹给你改 (emit(eventName, data))
想用兄弟的数据, 想改兄弟的数据，或者想用其他哥们的。哦豁，够不到，有一个法子， 如果同一个爹，就让爹去改。不同， vuex跳出来说， 都给我吧，想共享啥，甩给我。 同时呢， 为了好记账， 就规定了， 想取呢，您就直接取完事。想改呢， 就还是得按规矩来， 你想改成啥都告诉我， 我帮你改。 

总结一下：vue 极度贴近传统的html开发，依旧是html+css+js 分离，大家各干个事，然后呢， 提供了一个模子 (.vue), 你把这三个部分都扔里面去，然后vue说你就别管呢，我来帮你解析这个东西，你就把他喊成组件，想用的时候直接给个代号，就可以在其他地方用了。上手难度及低， 基本你会写普通的html你就会用vue。

#### 生命周期
1.beforeCreate 
$options 配置对象初始化完成, 包括一些属性 $parent $children $root, 方法 $on $off $watch $nextTick初始化完成， 作为业务开发， 很少在这个钩子里面做事情, 但是确是各种vue插件注入自己的方法及属性的大好时机, 比如vuex, 在beforeCreate阶段向vue实例注入$store, 使得根实例下的每一个vue实例都可以使用$store.


