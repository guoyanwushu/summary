## 构建工具

* 项目里webpack的优化
* webpack构建流程
* webpack插件原理
* 有自己写过插件么
* 从零构建一个webpack项目可以么
* load的原理
* 描述一下splitChunkPlugin
* 


## HTTP
* 三次握手 、四次挥手
* HTTP和TCP的区别
    一个是应用层协议，一个是传输层层协议。HTTP协议传输数据前需要通过TCP建立连接
* HTTP2对比HTTP1.1对比HTTP1.0
    HTTP1.1 新增了缓存控制管理方案(if None Match), 新增了长链接(keep-alive), 新增了错误状态管理, 新增了Host， range头字段
    HTTP2.0 新增了头部压缩方案，新增了多路复用方案，以二进制流的形式替换之前的文本传输
* HTTP2是怎么解决队头阻塞的？
    首先来了解一下为什么会有队头阻塞，因为http1.1的协议数据传输传输的是文本，比如服务端要发送hello world给客户端，他就只能一个一个按照顺序发，然后客户端一个一个接，接完了组装成
    完整的消息，然后进行解析。如果发hello world的同时 又想发i am ok给客户端，试想一下，如果并行发，由于是文本，客户端可能接收到的就是hiamelloworokd, 由于文本的限制，根本就解析不出来正确的消息了。所以响应必须一个一个去发送，如果前面的响应卡住了，后面的响应就必须等，这就是队头阻塞的原因。
    
    然后HTTP2, 不采用文本形式进行传输了，而是将数据转换为二进制形式, 然后切割成帧来进行传输。帧里保存着属于哪个流，流和不同的响应一一对应。同时上面的例子，比如响应hello world，开启一个流H, 然后把hello world 组装成两个帧, 帧1帧2，帧里面存着他属于流H的标识字段。然后响应i am ok,开启流I, 将i am ok组装成3个帧, 同理这三个帧也存着他属于流I的标识字段。然后就并行发送这些数据帧，接收的一方，根据帧属于流的标识，将帧进行分离，然后根据帧顺序，组装成完整的消息。由于有流标识，可以区分不同的响应，又有帧顺序，不怕数据乱掉。就算某个响应阻塞了，也是阻塞他自己的流，对其他的流没有影响，这样子就解决了队头阻塞问题。
* HTTP2是如何压缩头部的?
    通过客户端和服务端共同维护1个静态表和动态表，用索引直接替代键值对进行传输。比如method: get, 在静态表的索引为2，那么头部该字段就会直接发送2，服务端接到2之后，去静态表里
    面取出method: get替代。静态表里面一共定义了61个常用的头部键值队，当传输的头部在静态表里没有对应的索引时，就会往静态表的后面，继续新增一条数据，索引对应当前的键值对。并且会通知
    服务端也在服务端的静态表里加一条数据。 这样子第二次传输该头部的时候，就可以用索引去替代了。
* 为什么说HTTPS比HTTP安全
    数据加密、身份判定、完整性校验
* 对称加密和非对称加密
    对称加密就是加密和解密都是用的同一个秘钥。非对称加密就是公钥加密私钥解密，或者私钥加密，公钥解密。
* HTTP请求的时候什么时候用的对称加密什么时候用的非对称加密?
* 描述一下HTTPS的完整通信流程和其中使用到的技术?
    对称加密、非对称加密、散列算法
* 对称加密的原理

* 攻击
* 有关HTTP缓存的首部字段说一下
* HTTP中的keep-alive有了解吗？
* 在一次传输中它是如何保证每个数据包之间的顺序的？
* 具体说一下HTTP/2中的多路复用
* GET和POST的区别
* 为什么说GET会留下历史记录？
* GET可以上传图片吗？
    虽然不知道怎么传，但是貌似真的可以用get上传图片哎
* GET和POST的安全性问题为什么说POST相对安全一些
* GET就一定是幂等的吗？
    理论上是幂等的，但是不排除后端的设计会在get请求中变更服务器状态
* 说一下你所知道的缓存方案
    cookie/localstorage/sessionstorage/indexDB/甚至dom本身也是可以缓存数据的

## JS基础
* EventLoop
* requestAnimationFrame属于宏任务还是微任务
* 输入URL到页面的呈现
* script与css还有页面的渲染顺序
* script标签的async是什么时候加载的
* 说一下==数据类型转换吧
* 说一说原型链
* null为什么被typeof错误的判断为了'object'
* 说一说几种this指向
* 使用箭头函数时需要注意什么？
* 说一下JS内置对象
* 描述一下作用域链
* 闭包的使用场景
* 使用闭包需要注意什么
* 用过哪些ES6的功能
* 谈谈你对模块的理解

## css
* position属性有哪些值分别介绍一下
* relative的定位规则
* 脱离文档流是会呈现什么样的效果呢？
* 常规流(文档流)是个怎样的排列关系
* inline-block的使用场景
* 有做过移动端项目么，说一下你们的适配方案
* 怎么让移动端项目在PC端也能较好的使用
* 








## node
* 有用过node吗？比如用它写一些中间层

## vue
* 动态组件和普通组件有什么区别，能不能讲一下?
* 说一下keepAlive的原理?
* 讲一下$set的原理，有没有了解过数组是如何处理使得其具有双向绑定功能?
* Watcher 到底是什么?和Dep的关系?有什么作用?
    从名字差不多就能看出来，Watcher就是一个观察者，有自己的值(value), 保存有观察的对象 (expOrFn), 和观察的回调 (cb), 并且有自己的一些方法 (update\run\evalute), 同时也有一些自己的标识(dirty/lazy/等等). 通过new 注册一个观察者，然后new的过程中就会进行一次观察, 他自己在观察的时候同时会被被观察者进行收集(当你凝视深渊的时候，深渊也在凝视着你)。通过Watcher的初始化，被观察者自动收集了观察者，然后被观察者更新的时候，就会去通知观察者再次进行观察。


    Watcher来源一共有三类 
    1. renderWatcher 
        在beforeMount执行后, 会新建一个render Watcher （vm._update(vm.render(), ), new的时候, watcher内部执行 this.get()的时候，会执行 vm._update(vm.render())， vm.render() 生成虚拟dom树的过程，实际上就完成
    了依赖收集， 因为这个时候的Dep.target一直就是这个watcher，所以收集到的也全都是这个Watcher。 vm.render()执行完了之后， vm.update()执行，这个时候其实就是执行的mount, 虚拟dom到真实dom的映射过程了。new Watcher执行完了之后就会
    调用 mounted 钩子.
    2. computed
        在initData 和 initProps initMethods 后，就会执行 initComputed, 通过watcher的dirty属性来控制缓存
    3. $watch
        
* Dep又是什么?
    Dep和data对象的属性一一对应，每一个data对象的属性(包括孙子属性)，都有一个对应的Dep对象，该属性所收集的所有依赖都保存在Dep对象的subs属性里面。 如何收集依赖? 依赖从何处来 ? 但从dep视角看，依赖都是从Dep.target来的，在收集依赖的时候
    收集的也是Dep.target。 那么问题来了，Dep.target又是啥? Dep.target又是哪里来的呢?
        一个是computed， 一个是new Watcher时建立的， 一个是$watch 来的
* vue中key的作用    
    1. 利用key规避diff时的最大化复用策略，使得前后dom更新时能够触发完整的生命周期并且能够触发过渡
    2. 同样是利用key，使得updateChildren的时候，在四轮首位对比均未命中的情况下可以更快定位到旧节点中的相同节点，间接的提升效率。
    可以看起来key的作用都是和dom复用有关的, 一方面是规避复用策略，一方面又是促进复用策略。
* 可以将key设置为Math.random()随机数么

    不能, 如果把key设置为Math.random(), 将会导致diff时，sameNode极大概率会判定失败，导致几乎无法复用旧的节点，每一次update都将会走remove和create的策略，真实dom的删除新增是代价非常大的，将会导致非常大的性能损失。
* 如果让你设计一个双向绑定，会怎么设计
    先这样，再那样，再这样，最后那样，完成
* 说一下Vue的diff算法，能不能描述一下vue的diff流程?

    vue通过diff算法来控制dom更新粒度, 最大化利用dom复用，尽量以最小的代价来完成dom更新。首先diff只在同层节点间进行，如果判断sameNode失败，就会删除旧节点，创建新节点
插入原有位置，如果sameNode成功就会进入diff流程，在原有真实节点上更新。在前后都有children的情况下，进入childrendiff
流程，会尝试最大化利用之前的已有节点作更新，然后对新增节点和移除节点作对应的真实dom创建和新增。
    
* vue diff算法的缺点?
    事实上每一次diff都必须从根节点开始逐层对比，即便是完全静态的节点，也必须经过diff流程。可能一个vDom只有最后一个元素的一个文本引用了data数据，那么之前的所有diff都没有意义, 只有最后
    一个节点的diff是有意义的diff。vue3中，通过打标签的形式，在compiler生成vNode的时候加上patchFlags来标识动态节点，最终生成一个动态节点树，patch的时候不再进行整个vNode树对比，而只进行动态节点树对比，提高了diff效率。
* Vue的双向绑定原理，Object.defineProperty()有什么缺点？Vue3为什么用Proxy?
    * 原理
    递归遍历data对象，劫持其对象属性，重新定义get和set方法，通过get
    defineProperty有缺陷，无法识别到对象属性的新增删除和数组的直接索引变更以及length变更,而proxy原生支持。另外一方面Object.defineProperty是属性级别的劫持，必须遍历对象的每一个属性进行劫持，而proxy是对象级别的劫持，无须进行数学家别的深层次遍历
* nextTick实现原理
    向callbacks里添加一个处理函数。在当前的同步任务执行完成后，就会去callbacks里面取出来，挨个执行
* nextTick中的waiting是什么时候变为true的呢    
    每一个更新队列开始时，第一次执行queueWatcher时，waiting被设置为true。在队列更新全部完成后, waiting被重置为false
* 说一下虚拟DOM的作用以及实现原理    
     
    虚拟dom是将真实dom中我们最关注一的一些特性抽离处理，比如属性、节点类型、事件等以js对象树代替真实的dom树来进行维护，一方面虚拟dom更轻量化，另外一方面可以通过diff算法，实现由数据驱动，完全自动的dom更新。
* Vue3有哪些新的API或者有做哪些优化？
    * 新api
        * 组合式api
        vue3将2.0中常见的选项式api进行抽离，将响应式属性，生命周期钩子等常见的功能选项抽离成单独的函数，通过引入并使用的形式来完成业务逻辑
            优点:    
                1. 通过函数而非选项来完成相关的业务功能，可以获得完整的代码提示和类型推导，利用typescript开发vue应用也变得更加容易
                2. 于组件而言，逻辑将会更加清晰，对应的逻辑块可以集中处理并抽离，而不是分散在选项的各处，更有利于阅读和维护
                3. 受益于vue3的tree shaking技术，按需引入将使得最终的生成文件可以剔除掉没有用到的功能代码，生产文件将更小
                4. 组合式api更利于功能复用，不再受限于this的限制，可以在功能上进行更细粒度的抽离重用
        * 配置api更改
        在2.0中，所有的mixin 插件 指令等最终都会挂在在vue对象上，第三方出现的异常将会污染整个vue对象。在3.0中，通过 app  = createApp() , 然后 app.use app.component app.directive, 都会挂载在app实例上，不会对根vue对象产生影响
        * vue-fragement
        解决根节点只能有一个的问题
        * suspense
        在组件未彻底加载成功之前显示后备组件，比如loading等
        * v-model
        3.0支持可以带属性名的v-model指令
        * Portals
        在当前组件之外显示某些内容, 比如弹出窗口，tagView的右侧小菜单等，逻辑上属于当前组件容器，但是却不得不放到组件外比如body上面去
        * 新的自定义指令api
        于组件声明周期一致，更容易理解。beforeMount mounted beforeUpdate updated beforeUnmount unmounted

    * 优化
        * 全局api tree shakeable 按需导入，未用到的功能将会被剔除
        * proxy实现的数据劫持监听
            解决Object.defineProperyty 不能检测对象属性新增和删除，数组索引及length修改的响应式变化， 在对象级别建立监听而不用遍历递归在每一个属性上建立监听，效率大大提升
        * diff算法更新
        
* 如果不用vuex，你有什么方案可以实现类似的功能么?

* 谈一谈vuex的原理，有了解过其他的持久化方案么比如redux，说一下他们的区别
    vuex其实就是把需要持久化的数据提取到一个单独的vue实例中，然后通过berforeCreate钩子，在vue实例及子组件中注入$store属性指向该实例, vuex禁止直接修改state，只能通过commit mutation或者dispatch action 来进行数据变更
* 

## 项目
* 权限控制，路由权限和按钮权限
    1. 菜单权限
        在登录后，根据用户名，去菜单权限表中去拉取该用户的对应菜单权限，然后动态生成菜单。对传统页面而言，如果用户知道具体的页面地址，是可以通过直接访问页面绕过菜单权限控制。当确实出现了这种情况，就要通过按钮权限来规避非法访问的用户进一步操作。
    2. 路由权限
        如果是vue或者react写的单页应用，一种路由权限控制是由后端根据用户鉴权后返回该用户独有的路由列表，然后由前端组装成菜单及路由, 将未定义路由全部重定向到404，这样子的做法可以规避
        上述的问题。
    3. 按钮权限
        在某些页面的某些按钮，比如通过、删除、驳回等功能性按钮, 于前端而言，可以为权限按钮单独设定组件，根据用户当前的授权信息来决定按钮的显示与否，另外一方面为了安全考虑，服务端也应该对重要操作进行权限判定。
* 按钮权限有几种控制方式
    
* token一般放在哪里
* token放在Cookie、sessionStorage、localStorage有什么不同
* Cookie有哪些安全问题、如何预防
* SameSite设置为了lax之后是怎样来控制Cookie的发送的，如果顶级域名不同会发送吗
* 如果使用jsonp的话会有什么安全问题吗？
* 你们有做过单点登陆吗?
    做过，
* 有用过ngnix吗？用它做过哪些事？
* 项目里做过哪些优化？
* 你认为你做的项目最大的亮点在哪里
* 项目中碰到的技术难点
* 动态表单的实现
* 你们项目一般是如何做缓存的
* 项目中的环境变量是如何控制的？
* 假设有两个子项目，他们需要共用同一个用户体系如何保证关掉页面之后打开另一个项目用户还是登录状态
* 首屏加载优化
* SSR的使用场景
* 你们的UI组件库怎么实现按需引入的呢？
* 如果有一个组件需要和前面的组件相关联你会怎么做
* 说一下你们的工作流

